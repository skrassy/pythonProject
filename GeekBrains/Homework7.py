from abc import ABC, abstractmethod

# Задание 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод init()),
# который должен принимать данные (список списков) для формирования матрицы.
# Следующий шаг — реализовать перегрузку метода str() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода add() для реализации операции сложения двух объектов класса Matrix
# (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой
# матрицы складываем с первым элементом первой строки второй матрицы и т.д.


class Matrix:

    def __init__(self, *params):
        self.my_matrix = []
        for el in params:
            self.my_matrix.append(el)

    def __getitem__(self, index):
        return self.my_matrix[index]

    def __str__(self):
        return '\n'.join(' '.join(str(col) for col in row) for row in self.my_matrix)

    def __add__(self, other):
        return [list(sum(pair) for pair in zip(self.my_matrix[i], other[i])) for i in range(len(self.my_matrix))]


def matrix_format(matrix):
    return '\n'.join(' '.join(str(col) for col in row) for row in matrix)


matrix1 = Matrix([1, 4, 6, 1], [2, 1, 3, 5])
matrix2 = Matrix([3, 5, 4, 1], [2, 7, 3, 6])
print(f'Матрица № 1: \n{matrix1} \nМатрица № 2: \n{matrix2} \n')
sum_matrix = matrix1 + matrix2
print(f'Результат сложения матриц 1 и 2: \n{matrix_format(sum_matrix)}')


# Задание 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность
# (класс) этого проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте
# относятся пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для
# костюма (2*H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать
# абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.


class MyAbstractClass(ABC):
    @abstractmethod
    def calc(self):
        pass


class Coat(MyAbstractClass):
    def __init__(self, size):
        self.size = size

    @property
    def calc(self):
        return f"Количество ткани, необходимое для пошива пальто: {'{0:.3}'.format(self.size / 6.5 + 0.5)}"


class Suit(MyAbstractClass):
    def __init__(self, height):
        self.height = height

    @property
    def calc(self):
        return f"Количество ткани, необходимое для пошива костюма: {'{0:.3}'.format(self.height * 2 + 0.3)}"


coat_1 = Coat(44)
suit_1 = Suit(1.64)
print(f'Размер пальто: {coat_1.size}')
print(coat_1.calc)
print(f'Размер костюма: {suit_1.height}')
print(suit_1.calc)


# Задание 3. Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать
# класс Клетка. В его конструкторе инициализировать параметр, соответствующий количеству ячеек клетки
# (целое число). В классе должны быть реализованы методы перегрузки арифметических операторов: сложение (add()),
# вычитание (sub()), умножение (mul()), деление (truediv()). Данные методы должны применяться только к клеткам
# и выполнять увеличение, уменьшение, умножение и целочисленное (с округлением до целого) деление клеток,
# соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных
# двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек
# двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества
# ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление
# количества ячеек этих двух клеток.
# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному
# аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет
# строку: *****\n*****\n*****.

class Cell:

    def __init__(self, unit):
        self.unit = unit

    def __str__(self):
        return f"Клетка, содержащая {self.unit} ячеек"

    def __add__(self, other):
        return f"Результат сложения клеток: {Cell(self.unit + other.unit)}"

    def __sub__(self, other):
        sub = Cell(self.unit - other.unit)
        return f"Результат вычитания клеток: {sub}" if sub.unit >= 0 else f"Ошибка! Вычитать нельзя!"

    def __mul__(self, other):
        return f"Результат умножения клеток: {Cell(self.unit * other.unit)}"

    def __truediv__(self, other):
        div = Cell(self.unit // other.unit).unit
        return f"Результат деления клеток: {div}" if div >= 1 else f"Делить нельзя! Число ячеек не может быть меньше 1"

    def make_order(self, n):
        row = ''
        for i in range(int(self.unit / n)):
            row += f'{"*" * n} \n'
        row += f'{"*" * (self.unit % n)}'
        return f"Отображение клетки в виде рядов по {n} ячеек \n{row}"


cell_1 = Cell(10)
cell_2 = Cell(5)
cell_3 = Cell(20)
print(cell_1)
print(cell_1 + cell_2)
print(cell_1 - cell_2)
print(cell_1 - cell_3)
print(cell_2 * cell_3)
print(cell_1 / cell_2)
print(cell_2 / cell_1)
print(cell_1.make_order(5))
print(cell_3.make_order(4))
print(cell_3.make_order(8))


